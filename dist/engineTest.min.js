define("matchStats",[],function(){return{matchesPlayed:0,matchesWon:0,matchesLost:0,matchesDrawn:0,totalTurns:0,totalPoints:0}}),function(){require("matchStats");var noop=function(){};window.ga=noop,define("animations",[],function(){return{}}),define("debugLog",[],function(){return{enabled:!1,getLog:function(){return""},clear:noop,prepend:noop,prependLines:noop,append:noop,appendLines:noop}}),define("log",[],function(){return{}}),define("ui",[],function(){return{show:noop,hide:noop,getSelectedBattlegrounds:noop,getSelectedMapBattlegrounds:noop,generateLink:noop,displayText:noop,displayTurns:noop,showWinrate:noop,hideTable:noop,setSimStatus:noop,loadDeckBuilder:noop,updateGameData:noop,loadSavedDeck:noop,toggleTheme:noop}})}(),define("debugMessages",["debugLog","skillApi","log"],function(debugLog,skillApi,log){"use strict";var reason;function _logCannotAttack(reason){return _logCannotDo(reason,"attack")}function _logCannotDo(reason,action){return function(unit){debugLog.appendLines(log.name(unit)+" is "+reason+" and cannot "+action)}}function logSkillStopped(sourceUnit,skillVerb,target,reason){debugLog.appendLines(log.name(sourceUnit)+" "+skillVerb+" "+_getTargetName(target,sourceUnit)+" but it is "+reason+"!")}function _logOutcomeFound(desiredOutcome,matchesPlayed){debugLog.prependLines(desiredOutcome+" found after "+matchesPlayed+" games. Displaying debug output...",""),debugLog.appendLines("","<h1>"+desiredOutcome.toUpperCase()+"</h1>")}function _logOutcomeNotFound(desiredOutcome,matchesPlayed){debugLog.appendLines("No "+desiredOutcome+" found after "+matchesPlayed+" games. No debug output to display.")}function _getTargetName(target,source){return target===source?"itself":log.name(target)}function _logDrawCard(commander,deck,i){var card=deck[i];return card?commander+" draws "+log.name(card,!0):""}return{logDead:function(unit){debugLog.appendLines(log.name(unit)+" <strong>is removed from field</strong>")},logCardPlayed:function(commander,card){(debugLog.enabled||debugLog.cardsPlayedOnly)&&debugLog.appendLines(log.name(commander)+" plays "+_getTargetName(card))},logDamage:function(sourceUnit,targetUnit,skillName,skillVerb,damageInfo,logFn){debugLog.append("<u>("+skillName+": +"+damageInfo.originalDamage),damageInfo.modifiers&&Object.keys(damageInfo.modifiers).forEach(function(name){var value=damageInfo.modifiers[name];value&&debugLog.append(" "+name+": "+(0<value?"+":"")+value)});debugLog.appendLines(") = "+(damageInfo.damage||damageInfo.originalDamage)+" damage</u>"),sourceUnit?debugLog.append(log.name(sourceUnit)+" "+skillVerb+" "+_getTargetName(targetUnit,sourceUnit)+" for "+damageInfo.damage+" damage"):debugLog.append(log.name(targetUnit)+" takes "+skillVerb+" damage");debugLog.append(targetUnit.isAlive()?"":" and it dies");var additionalDebug=logFn&&logFn();additionalDebug&&debugLog.append(additionalDebug);debugLog.appendLines()},logNotImplemented:function(skillID,unit){var skillName=SKILL_DATA[skillID]?SKILL_DATA[skillID].name:skillID;debugLog.appendLines(log.name(unit)+" attempts to use "+skillName+", but it is not implemented.")},logDualstrike:function(unit){debugLog.appendLines(log.name(unit)+" activates dualstrike")},logCannotValor:function(unit,enemy){debugLog.appendLines(log.name(unit)+" activates valor but "),enemy?debugLog.appendLines("enemy is not strong enough."):debugLog.appendLines("there is no opposing enemy.")},logSilenced:(reason="silenced",_logCannotDo(reason,"use skills")),logFrozen:_logCannotAttack("frozen"),logWeakened:_logCannotAttack("weakened"),logImbuesNew:function(sourceUnit,targetUnit,imbuedSkill,amount){debugLog.appendLines(log.name(sourceUnit)+" imbues "+log.name(targetUnit,!1)+" existing "+log.skill(imbuedSkill)+" by "+amount)},logImbuesExisting:function(sourceUnit,targetUnit,imbuedSkill,amount){debugLog.appendLines(log.name(sourceUnit)+" imbues "+log.name(targetUnit,!1)+" with "+log.skill(imbuedSkill)+"("+amount+")")},logScorch:function(sourceUnit,amount,targetUnit){debugLog.appendLines(log.name(sourceUnit)+" inflicts scorch("+amount+") on "+_getTargetName(targetUnit,sourceUnit))},logNullified:function(sourceUnit,skillVerb,target){logSkillStopped(sourceUnit,skillVerb,target,"nullified")},logInvisibile:function(sourceUnit,skillVerb,target){logSkillStopped(sourceUnit,skillVerb,target,"invisible")},logStatusEffect:function(sourceUnit,skillVerb,target,enhanced,amount,additionalDebug){enhanced&&debugLog.appendLines("<u>(Enhance: +"+enhanced+")</u>");var line=log.name(sourceUnit)+" "+skillVerb+" "+_getTargetName(target,sourceUnit)+(amount?" by "+amount:"");additionalDebug&&(line+=additionalDebug(target,amount));debugLog.appendLines(line)},logInflicts:function(sourceUnit,statusName,statusValue,target){debugLog.appendLines(log.name(sourceUnit)+" inflicts "+statusName+(statusValue?"("+statusValue+")":"")+" on "+_getTargetName(target,sourceUnit))},logGainAttack:function(unit,skillVerb,amount){debugLog.appendLines(log.name(unit)+" "+skillVerb+" and gains "+amount+" attack!</br>")},logGainHealth:function(unit,verb,amount){debugLog.appendLines(log.name(unit)+" "+verb+" "+amount+" health")},logChargeSkill:function(unit,skill){skill.countdown?debugLog.appendLines(log.name(unit)+" charges "+skillApi.nameFromId(skill.id)+" (ready in "+skill.countdown+" turns)"):debugLog.appendLines(log.name(unit)+" readies "+skillApi.nameFromId(skill.id))},logReanimate:function(unit){debugLog.appendLines(log.name(unit)+" is reanimated</br>")},logAction:function(sourceUnit,skillVerb,target){debugLog.appendLines(log.name(sourceUnit)+"  "+skillVerb+(target?" "+_getTargetName(target,sourceUnit):""))},logOutcome:function(result,matchesPlayed,remainingSims){debugLog.firstLoss?"draw"===result?_logOutcomeFound("Draw",matchesPlayed):result?(debugLog.clear(),remainingSims||_logOutcomeNotFound("losses",matchesPlayed)):_logOutcomeFound("Loss",matchesPlayed):debugLog.firstWin?result&&"draw"!==result?_logOutcomeFound("Win",matchesPlayed):(debugLog.clear(),remainingSims||_logOutcomeNotFound("wins",matchesPlayed)):debugLog.massDebug&&function(result){debugLog.appendLines(""),"draw"===result?debugLog.appendLines("<h1>DRAW</h1>"):result?debugLog.appendLines("<h1>WIN</h1>"):debugLog.appendLines("<h1>LOSS</h1>")}(result)},logStartBattle:function(remainingSims){debugLog.massDebug&&remainingSims&&debugLog.appendLines("","<hr>NEW BATTLE BEGINS<hr>")},logTurnStart:function(turn,activePlayer,field,deck){var commander=log.name(field[activePlayer].commander),deck=deck[activePlayer].deck;debugLog.appendLines('<div id="turn_'+turn+'" class="turn-info"><hr/><br/><u>Turn '+turn+" begins for "+commander+"</u>"),turn<=2&&(debugLog.appendLines(_logDrawCard(commander,deck,0)),debugLog.appendLines(_logDrawCard(commander,deck,1)));debugLog.appendLines(_logDrawCard(commander,deck,2))},logTurnEnd:function(turn){debugLog.massDebug&&debugLog.append("<u>Turn "+turn+" ends</u></br></br></div>")}}}),define("debugDisabled",["debugMessages"],function(debugMessages){"use strict";var api={};return Object.keys(debugMessages).forEach(function(methodName){api[methodName]=function(){}}),api.logCardPlayed=debugMessages.logCardPlayed,api}),define("simController",["matchTimer","debugLog","debugMessages","debugDisabled"],function(matchTimer,debugLog,debugMessages,debugDisabled){"use strict";var SIM_CONTROLLER={debugEnd:function(){SIMULATOR.remainingSims=0,matchTimer.stop();var matchPoints,result=SIM_CONTROLLER.processSimResult();SIMULATOR.config.cpuHash&&(matchPoints=SIMULATOR.calculatePoints());SIM_CONTROLLER.onDebugEnd(result,matchPoints),SIM_CONTROLLER.endSimsCallback&&SIM_CONTROLLER.endSimsCallback()},onDebugEnd:function(){},endSimsCallback:null,stop_sims_callback:null,setDebugLogger:function(){this.logger=debugLog.enabled?debugMessages:debugDisabled}};return window.SIM_CONTROLLER=SIM_CONTROLLER}),define("bgeApi",["log","cardApi","debugLog","unitInfoHelper"],function(log,cardApi,debugLog,unitInfoHelper){var api={getBattlegrounds:function(matchBges,selfBges,enemyBges,mapBges,campaignID,missionLevel,raidID,raidLevel){var battlegrounds={onCreate:[],onTurn:[],onCardPlayed:[]};addBgesFromList(battlegrounds,matchBges),addBgesFromList(battlegrounds,selfBges,"player"),addBgesFromList(battlegrounds,enemyBges,"cpu"),function(battlegrounds,mapbges,player){if(mapbges)for(var selected=mapbges.split(","),i=0;i<selected.length;i++){var parts=selected[i].split("-"),location=parts[0],index=parts[1],value=parts[2],mapBGE=Object.keys(MAP_BATTLEGROUNDS).filter(function(id){return MAP_BATTLEGROUNDS[id].location_id==location})[0],battleground=(mapBGE=MAP_BATTLEGROUNDS[mapBGE]).effects[index].upgrades[value];addBgeFromList(battlegrounds,battleground,player)}}(battlegrounds,mapBges,"player"),campaignID?function(battlegrounds,campaignID,missionLevel){var campaign=CAMPAIGNS[campaignID];if(campaign){var id=campaign.battleground_id;if(id){var battleground=BATTLEGROUNDS[id];if(missionLevel=Number(missionLevel)-1,!battleground.starting_level||Number(battleground.starting_level)<=missionLevel){if(battleground.scale_with_level){battleground=JSON.parse(JSON.stringify(battleground));for(var levelsToScale=missionLevel-Number(battleground.starting_level),i=0;i<battleground.effect.length;i++){var effect=battleground.effect[i];effect.mult=effect.base_mult+effect.mult*levelsToScale}}addBgeFromList(battlegrounds,battleground,"cpu")}}}}(battlegrounds,campaignID,missionLevel):raidID&&function(battlegrounds,raidID,raidLevel){var bge_id=RAIDS[raidID].bge;if(bge_id){var battleground=BATTLEGROUNDS[bge_id];if(battleground&&Number(raidLevel)>=Number(battleground.starting_level))for(var enemy_only=battleground.enemy_only,j=0;j<battleground.effect.length;j++){var effect=battleground.effect[j],effect_type=effect.effect_type;if("skill"===effect_type){if(battleground.scale_with_level)var mult=battleground.scale_with_level*(raidLevel-battleground.starting_level+1);else var mult=1;var bge=cardApi.makeBattleground(battleground.name,effect,mult);bge.enemy_only=enemy_only,battlegrounds.onTurn.push(bge)}else if(0<=["evolve_skill","add_skill","scale_attributes","statChange","runeMultiplier"].indexOf(effect_type)){var bge=MakeSkillModifier(battleground.name,effect);bge.enemy_only=enemy_only,battlegrounds.onCreate.push(bge)}else if(0<=["scale_attack","scale_health"].indexOf(effect_type)){var bge=MakeStatScalar(battleground.name,effect);bge.enemy_only=enemy_only,battlegrounds.onCreate.push(bge)}else if("trap_card"===effect_type){var bge=MakeTrap(battleground.name,effect);bge.enemy_only=enemy_only,battlegrounds.onCardPlayed.push(bge)}}}}(battlegrounds,raidID,raidLevel);return battlegrounds}};function MakeSkillModifier(name,effect){return{name:name,modifierType:effect.effect_type,effects:[effect]}}function MakeStatScalar(name,effect){return{name:name,modifierType:"scale_stat",scaledStat:effect.effect_type.replace("scale_",""),effects:[effect]}}var OnPlayBGE,Trap,MakeOnPlayBGE=((OnPlayBGE=function(name,effect){this.p=null,this.name=name,this.effect=effect,this.runes=[]}).prototype={onCardPlayed:function(card){SIMULATOR.onPlaySkills[this.effect.id](this,card,this.effect)},isCommander:function(){return!1},isAssault:function(){return!1}},function(name,effects){return new OnPlayBGE(name,effects)}),MakeTrap=((Trap=function(name,trap_card){this.name=name,this.id=trap_card.id,this.base=trap_card.base,this.mult=trap_card.mult,this.target_deck=trap_card.target_deck,this.y=trap_card.y}).prototype={onCardPlayed:function(card,p_deck,o_deck){var deck="opponent"===this.target_deck?o_deck:p_deck;if(card.isInFaction(this.y)){for(var targets=[],t=0;t<deck.length;t++)(card=deck[t]).trap||targets.push(card);if(targets.length){var trapLevel=Math.ceil(card[this.base]*this.mult),trapInfo=unitInfoHelper.create(this.id,trapLevel),trap=cardApi.byId(trapInfo);targets[~~(Math.random()*targets.length)].trap=trap,debugLog.enabled&&debugLog.appendLines(this.name+" inserts "+log.name(trap)+" into the opposing deck.")}}}},function(name,effects){return new Trap(name,effects)});function addBgeFromList(battlegrounds,battleground,player){for(var j=0;j<battleground.effect.length;j++){var effect=battleground.effect[j],effect_type=effect.effect_type;if("skill"===effect_type){var bge=cardApi.makeBattleground(battleground.name,effect);"player"===player&&(bge.ally_only=!0),"cpu"===player&&(bge.enemy_only=!0),battlegrounds.onTurn.push(bge)}else if(0<=["evolve_skill","add_skill","scale_attributes","statChange","runeMultiplier"].indexOf(effect_type)){bge=MakeSkillModifier(battleground.name,effect);"player"===player&&(bge.ally_only=!0),"cpu"===player&&(bge.enemy_only=!0),battlegrounds.onCreate.push(bge)}else if(0<=["scale_attack","scale_health"].indexOf(effect_type)){bge=MakeStatScalar(battleground.name,effect);"player"===player&&(bge.ally_only=!0),"cpu"===player&&(bge.enemy_only=!0),battlegrounds.onCreate.push(bge)}else if("trap_card"===effect_type){bge=MakeTrap(battleground.name,effect);"player"===player&&(bge.ally_only=!0),"cpu"===player&&(bge.enemy_only=!0),battlegrounds.onCardPlayed.push(bge)}else if("on_play"===effect_type){(bge=MakeOnPlayBGE(battleground.name,effect.effect)).attacker=effect.attacker,bge.defender=effect.defender,bge.first_play=effect.first_play,"player"===player&&(bge.ally_only=!0),"cpu"===player&&(bge.enemy_only=!0),battlegrounds.onCardPlayed.push(bge)}}}function addBgesFromList(currentBgeList,newBges,player){if(!newBges)return null;for(var selected=newBges.split(","),i=0;i<selected.length;i++){var id=selected[i];addBgeFromList(currentBgeList,BATTLEGROUNDS[id],player)}}return api}),define("loadDeck",["cardInfo","cardApi","unitInfoHelper"],function(cardInfo,cardApi,unitInfoHelper){"use strict";function getMaxFusions(unit){for(var id=function(unit){for(var id,baseID=unit.id;id=baseID,void 0!==(baseID=REVERSE_FUSIONS[id]););return id}(unit),fusion=-1;void 0!==id;)fusion++,id=FUSIONS[id];return fusion}function getPresetUnit(unitInfo,level,maxedAt){if(level=parseInt(level),unitInfo.mastery_level&&level<parseInt(unitInfo.mastery_level))return null;if(unitInfo.remove_mastery_level&&level>=parseInt(unitInfo.remove_mastery_level))return null;var cardID=unitInfo.id,random=!1;cardID||(cardID=function(unitInfo){var possibilities=[];for(var id in CARDS)if(!REVERSE_FUSIONS[id]){var card=cardInfo.loadCard(id);if("1"!==card.card_type&&!(unitInfo.max_rarity&&Number(unitInfo.max_rarity)<Number(card.rarity)||unitInfo.min_rarity&&Number(unitInfo.min_rarity)>Number(card.rarity))&&(!unitInfo.type||unitInfo.type===card.type||0<=card.sub_type.indexOf(unitInfo.type))){if(unitInfo.set&&unitInfo.set.split(",").indexOf(card.set)<0)continue;possibilities.push(id)}}return possibilities[~~(Math.random()*possibilities.length)]}(unitInfo),random=!0);var unitLevel=unitInfo.level||1;if(maxedAt<=level)unitLevel=7,canFuse(cardID)&&(cardID=fuseCard(cardID));else if(1<level&&cardInfo.isCommander(cardID)){var upgradesPerLevel=(Number(cardInfo.loadCard(cardID).rarity)+1)/(maxedAt-1),levelsFromBase=level-1;unitLevel=Math.ceil(upgradesPerLevel*levelsFromBase)}var unit=unitInfoHelper.create(cardID,unitLevel);return random&&(unit.randomInfo={unitInfo:unitInfo,level:level,maxedAt:maxedAt}),unit}function upgradeCard(unitInfo){var maxLevel=parseInt(cardInfo.loadCard(unitInfo.id).rarity)+2;if(unitInfo.level===maxLevel){if(!canFuse(unitInfo.id))return!1;unitInfo.id=fuseCard(unitInfo.id,1),unitInfo.level=1}else unitInfo.level++;return!0}function canFuse(cardID){return!(-1<DoNotFuse.indexOf(cardID))&&(!cardInfo.isCommander(cardID)&&!!FUSIONS[cardID])}function fuseCard(cardID,fusion){if(-1===DoNotFuse.indexOf(cardID))if(fusion)for(var i=0;i<fusion;i++)cardID=doFuseCard(cardID);else do{var fused=doFuseCard(cardID);cardID=fused}while(cardID!==fused);return cardID}function doFuseCard(cardID){var fused=FUSIONS[cardID];return fused||cardID}var DoNotFuse=["8005","8006","8007","8008","8009","8010"];function loadPresetDeck(deckInfo,level,upgradeLevels){var maxedAt=upgradeLevels+1;level||(level=maxedAt);var current_deck=[];current_deck.deck=[];var commanderInfo=function(deckInfo,level){level=parseInt(level);var commander=deckInfo.commander;if(commander.card){for(var possibilities=[],i=0;i<commander.card.length;i++){var card=commander.card[i],minLevel=parseInt(card.min_mastery_level)||0,maxedAt=parseInt(card.max_mastery_level)||999;minLevel<=level&&level<=maxedAt&&possibilities.push(card)}(commander=possibilities[~~(Math.random()*possibilities.length)]).possibilities=possibilities}return commander}(deckInfo,level),commander=getPresetUnit(commanderInfo,level,maxedAt);commanderInfo.possibilities&&(commander.randomInfo={possibilities:commanderInfo.possibilities,level:level,maxedAt:maxedAt}),current_deck.commander=commander;var presetDeck=deckInfo.deck,deck=current_deck.deck;for(var current_key in presetDeck){var unit=getPresetUnit(presetDeck[current_key],level,maxedAt);unit&&deck.push(unit)}var upgradePoints=function(level,maxedAt,maxUpgradePoints){var percentCompvare;return percentCompvare=7===maxedAt?(level-1)/(maxedAt-1):level/maxedAt,Math.ceil(maxUpgradePoints*percentCompvare)}(level,maxedAt,function(deck){for(var maxUpgradePoints=0,i=0;i<deck.length;i++){var unit=deck[i],card=cardApi.byId(unit);maxUpgradePoints+=(getMaxFusions(card)+1)*card.maxLevel-1}return maxUpgradePoints}(deck));if(1<level&&level<maxedAt)for(var canFuse=deck.slice();0<upgradePoints&&0<canFuse.length;){var index=Math.floor(Math.random()*canFuse.length);upgradeCard(canFuse[index])?upgradePoints--:canFuse.splice(index,1)}return current_deck}function copyCardList(original_card_list){for(var new_card_list=[],key=0,len=original_card_list.length;key<len;key++)new_card_list[key]=original_card_list[key];return new_card_list}return{mission:function(id,level){var missionInfo=MISSIONS[id];return missionInfo?loadPresetDeck(missionInfo,level,6):0},raid:function(id,level,maxedAt){maxedAt||(maxedAt=25);var raidInfo=RAIDS[id];{if(raidInfo){var newRaidInfo={commander:raidInfo.commander,deck:raidInfo.deck.card};return loadPresetDeck(newRaidInfo,level,Number(raidInfo.upgradeLevels))}return 0}},defaultDeck:function(){return{commander:unitInfoHelper.defaultCommander,deck:[]}},copyCardList:copyCardList,copyDeck:function(original_deck){var new_deck={};return new_deck.commander=original_deck.commander,new_deck.deck=copyCardList(original_deck.deck),new_deck},getDeckCards:function(original_deck,owner){var new_deck={};new_deck.commander=cardApi.byId(original_deck.commander),new_deck.deck=[];for(var list=original_deck.deck,battlegrounds=SIMULATOR.battlegrounds.onCreate.filter(function(bge){return!("player"===owner&&bge.enemy_only||"cpu"===owner&&bge.ally_only)}),i=0,len=list.length;i<len;i++)new_deck.deck.push(cardApi.byIdWithBgeApplied(list[i],battlegrounds));return new_deck}}}),define("simulatorBase",["cardApi","base64","unitInfoHelper","loadDeck","simController"],function(cardApi,base64,unitInfoHelper,loadDeck,simController){"use strict";var SIMULATOR={};window.SIMULATOR=SIMULATOR;var playerDeckCached,cpuDeckCached,cpuCardsCached,playerCardsCached,max_turns=100;function playCard(card,p,turn,quiet){var field_p_assaults=field[p].assaults;if(!card.id)return 0;var newKey=field_p_assaults.length;if(unitInfoHelper.initializeUnit(card,p,newKey),card.played=!0,card.isAssault()&&(field_p_assaults[newKey]=card),quiet||simController.logger.logCardPlayed(field[p].commander,card),card.isTrap())doEarlyActivationSkills(card),doActivationSkills(card);else for(var i=0;i<battlegrounds.onCardPlayed.length;i++){var battleground=battlegrounds.onCardPlayed[i],o="player"===p?"cpu":"player",surge=SIMULATOR.config.surgeMode;if(battleground.defender){if(!surge&&"cpu"!==p)continue;if(surge&&"player"!==p)continue;battleground.owner=o}else if(battleground.attacker){if(!surge&&"player"!==p)continue;if(surge&&"cpu"!==p)continue;battleground.owner=p}else{if(battleground.enemy_only&&"cpu"!==p)continue;if(battleground.ally_only&&"player"!==p)continue;battleground.owner=p}1<turn&&battleground.first_play||battleground.onCardPlayed(card,deck[p].deck,deck[o].deck)}events.onCardPlayed(field,turn)}function removeDeadUnits(p){for(var units=field[p].assaults,key=0,len=units.length;key<len;key++){var current_assault=units[key];if(!current_assault.isAlive()){simController.logger.logDead(current_assault);var newkey=key;for(key++;key<len;key++)(current_assault=units[key]).isAlive()?(units[current_assault.key=newkey]=current_assault,newkey++):simController.logger.logDead(current_assault);units.length=newkey;break}}}function chooseRandomTarget(targets){return[targets[~~(Math.random()*targets.length)]]}function getOwner(card){return card.owner}function getOpponent(card){return"cpu"===card.owner?"player":"player"===card.owner?"cpu":void 0}function doDamage(sourceUnit,targetUnit,damage,logFn){damage>=targetUnit.health_left?targetUnit.health_left=0:targetUnit.health_left-=damage,logFn(),!targetUnit.isAlive()&&sourceUnit&&doOnDeathSkills(targetUnit,sourceUnit)}function getActivatedSkill(skillMap,skillId){return skillMap[skillId]||notImplemented}function notImplemented(sourceUnit,skill){return simController.logger.logNotImplemented(sourceUnit,skill),0}function doEarlyActivationSkills(sourceCard){var skills=sourceCard.earlyActivationSkills,len=skills.length;if(len)if(sourceCard.silenced)simController.logger.logSilenced(sourceCard);else{var dualstrike=sourceCard.dualstrike_triggered;simController.logger.logDualstrike(sourceCard);for(var activations=dualstrike?2:1,isAlive=makeLivenessCheck(sourceCard),a=0;a<activations;a++)for(var i=0;i<len&&isAlive();i++){var skill=skills[i];if(!skill.countdown){var affected=getActivatedSkill(earlyActivationSkills,skill.id)(sourceCard,skill);skill.c&&0<affected&&(skill.countdown=skill.c),events.onEarlyActivationSkills(field,turn,sourceCard)}}}}function alwaysTrue(){return!0}function makeLivenessCheck(maybeUnit){return maybeUnit.isAlive?maybeUnit.isAlive.bind(maybeUnit):alwaysTrue}function doOnDeathSkills(dying,killer){if(!dying.ondeath_triggered){var skills=dying.onDeathSkills,len=skills.length;if(0!==len){for(var i=0;i<len;i++){var skill=skills[i];onDeathSkills[skill.id](dying,killer,skill),events.onOnDeathSkills(field,turn,dying)}dying.ondeath_triggered=!0}}}var passiveSkills=["backlash","counter","counterburn","counterpoison","armored","evade","stasis"];function requiresActiveTurn(skillName){return-1===passiveSkills.indexOf(skillName)}function backlash(attacker,defender){if(attacker.isAssault()&&defender.isAlive()){var baseDamage=defender.backlash;doCounterDamage(attacker,defender,"Backlash",baseDamage,unitInfoHelper.getEnhancement(defender,"backlash",baseDamage))}}function checkShroud(unit){return unit.isActive()&&unit.isUnjammed()?0:unit.stasis||0}var activationSkills={burnself:function(sourceUnit,skill){var scorch=skill.x;return sourceUnit.scorched?(sourceUnit.scorched.amount+=scorch,sourceUnit.scorched.timer=2):sourceUnit.scorched={amount:scorch,timer:2},simController.logger.logScorch(sourceUnit,scorch),1},scorchbreath:function(sourceUnit,skill){return activationSkills.burn(sourceUnit,skill)},burn:function(sourceUnit,skill){var targets,o=getOpponent(sourceUnit),field_o_assaults=field[o].assaults;switch(skill.id){case"scorchbreath":var startKey=Math.max(0,sourceUnit.key-1),endKey=Math.min(field_o_assaults.length,sourceUnit.key+2);targets=field_o_assaults.slice(startKey,endKey);break;case"burnself":targets=[sourceUnit];break;default:targets=field_o_assaults.slice(sourceUnit.key,sourceUnit.key+1)}if(!targets.length)return 0;var scorch=skill.x;scorch+=unitInfoHelper.getEnhancement(sourceUnit,"burn",scorch);for(var affected=0,i=0;i<targets.length;i++){var target=targets[i];target.scorched?(target.scorched.amount+=scorch,target.scorched.timer=2):target.scorched={amount:scorch,timer:2},simController.logger.logScorch(sourceUnit,scorch,target),affected++}return affected},protect_seafolk:function(sourceUnit,skill){return activationSkills.protect(sourceUnit,skill,null,null,!0)},evadebarrier:function(sourceUnit,skill){return activationSkills.protect(sourceUnit,skill,"invisible",function(target,amount){return" and imbues it with invisible "+amount})},protect:function(sourceUnit,skill,additionalStatus,additionalDebug,onlyOnDelay){for(var faction=skill.y,p=getOwner(sourceUnit),protect=skill.x,all=skill.all,field_p_assaults=field[p].assaults,targets=[],key=0,len=field_p_assaults.length;key<len;key++){!(target=field_p_assaults[key]).isAlive()||!target.isInFaction(faction)||onlyOnDelay&&target.isActive()||targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,protect);protect+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var target;if((target=field_p_assaults[targets[key]]).nullified)target.nullified--,simController.logger.logNullified(sourceUnit,"protects",target);else{affected++;var amount=protect;if(!amount){var mult=skill.mult;target.isActive()||(mult+=skill.on_delay_mult||0),amount=Math.ceil(target.health*mult)}target.protected+=amount,additionalStatus&&(target[additionalStatus]=(target[additionalStatus]||0)+amount),simController.logger.logStatusEffect(sourceUnit,"barriers",target,enhanced,amount,additionalDebug)}}return affected},heal:function(sourceUnit,skill){for(var p=getOwner(sourceUnit),faction=skill.y,heal=skill.x,all=skill.all,field_p_assaults=field[p].assaults,targets=[],key=0,len=field_p_assaults.length;key<len;key++){(target=field_p_assaults[key]).isAlive()&&target.isInFaction(faction)&&(all||target.isDamaged())&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,heal);heal+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var target;if((target=field_p_assaults[targets[key]]).nullified)target.nullified--,simController.logger.logNullified(sourceUnit,"heals",target);else{affected++;var amount=heal;if(!amount){var mult=skill.mult;amount=Math.ceil(target.health*mult)}amount>target.health-target.health_left&&(amount=target.health-target.health_left),target.health_left+=amount,simController.logger.logStatusEffect(sourceUnit,"heals",target,enhanced,amount)}}return affected},poisonstrike:function(sourceUnit,skill){return activationSkills.strike(sourceUnit,skill,!0)},strike:function(sourceUnit,skill,poison){for(var o=getOpponent(sourceUnit),strike=skill.x,faction=skill.y,all=skill.all,field_x_assaults=field[o].assaults,targets=[],key=0,len=field_x_assaults.length;key<len;key++){(targetUnit=field_x_assaults[key]).isAlive()&&targetUnit.isInFaction(faction)&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,strike);strike+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var targetUnit;if((targetUnit=field_x_assaults[targets[key]]).invisible)targetUnit.invisible--,simController.logger.logInvisibile(sourceUnit,"bolts",targetUnit);else{affected++;var strike_damage=strike,damageInfo=modifySkillDamage(targetUnit,strike_damage,enhanced);strike_damage=damageInfo.damage;var poisonDamage=0;0<strike_damage&&poison&&targetUnit.isAlive()&&strike>targetUnit.poisoned&&(poisonDamage=strike,targetUnit.poisoned=poisonDamage),doDamage(sourceUnit,targetUnit,strike_damage,function(){simController.logger.logDamage(sourceUnit,targetUnit,"Strike","bolts",damageInfo,function(){if(poisonDamage&&!targetUnit.isAlive())return" and inflicts poison("+poisonDamage+") on it"})}),targetUnit.backlash&&backlash(sourceUnit,targetUnit)}}return affected},intensify:function(sourceUnit,skill){for(var o=getOpponent(sourceUnit),intensify=skill.x,faction=skill.y,all=skill.all,field_x_assaults=field[o].assaults,targets=[],key=0,len=field_x_assaults.length;key<len;key++){(target=field_x_assaults[key]).isAlive()&&target.isInFaction(faction)&&(target.scorched||target.poisoned)&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,intensify);intensify+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var target,intensifiedFields=(target=field_x_assaults[targets[key]]).scorched?"scorch":"";intensifiedFields+=target.poisoned?intensifiedFields?" and poison":"poison":"",target.invisible?(target.invisible--,simController.logger.logInvisibile(sourceUnit,"intensifies "+intensifiedFields+" on",target)):(affected++,target.scorched&&(target.scorched.amount+=intensify),target.poisoned&&(target.poisoned+=intensify),simController.logger.logStatusEffect(sourceUnit,"intensifies "+intensifiedFields+" on",target,enhanced,intensify),target.backlash&&backlash(sourceUnit,target))}return affected},ignite:function(sourceUnit,skill){for(var o=getOpponent(sourceUnit),faction=skill.y,field_x_assaults=field[o].assaults,targets=[],key=0,len=field_x_assaults.length;key<len;key++){var target=field_x_assaults[key];target.isAlive()&&target.isInFaction(faction)&&targets.push(key)}return applyDebuff(sourceUnit,skill,"ignites",targets,field_x_assaults,function(target,skillValue){target.scorch(skillValue)})},jamself:function(sourceUnit){return sourceUnit.jammed=!0,sourceUnit.jammedSelf=!0,simController.logger.logStatusEffect(sourceUnit,"freezes",sourceUnit),1},jam:function(sourceUnit,skill){for(var o=getOpponent(sourceUnit),all=skill.all,field_x_assaults=field[o].assaults,targets=[],key=0,len=field_x_assaults.length;key<len;key++){(target=field_x_assaults[key]).isAlive()&&(all||target.isActiveNextTurn()&&target.isUnjammed())&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var affected=0;for(key=0,len=targets.length;key<len;key++){var target;(target=field_x_assaults[targets[key]]).invisible?(target.invisible--,skill.countdown=0,simController.logger.logInvisibile(sourceUnit,"freezes",target)):(affected++,target.jammed=!0,simController.logger.logStatusEffect(sourceUnit,"freezes",target),target.backlash&&backlash(sourceUnit,target))}return affected},frost:function(sourceUnit,skill){var o=getOpponent(sourceUnit),frost=skill.x,enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,frost);frost+=enhanced;for(var field_x_assaults=field[o].assaults,targets=[],i=sourceUnit.key-1,end=i+2;i<=end;i++){(targetUnit=field_x_assaults[i])&&targetUnit.isAlive()&&targets.push(i)}if(!targets.length)return 0;for(var affected=0,key=0,len=targets.length;key<len;key++){var targetUnit;if((targetUnit=field_x_assaults[targets[key]]).invisible)targetUnit.invisible--,simController.logger.logInvisibile(sourceUnit,"breathes frost at",targetUnit);else{affected++;var frost_damage=frost,damageInfo=modifySkillDamage(targetUnit,frost_damage,enhanced);frost_damage=damageInfo.damage,doDamage(sourceUnit,targetUnit,frost_damage,function(){simController.logger.logDamage(sourceUnit,targetUnit,"Frostbreath","breathes frost at",damageInfo)}),targetUnit.backlash&&backlash(sourceUnit,targetUnit)}}return affected},heartseeker:function(sourceUnit,skill){var o=getOpponent(sourceUnit),heartseeker=skill.x,target=field[o].assaults[sourceUnit.key];return target?(heartseeker+=unitInfoHelper.getEnhancement(sourceUnit,skill.id,heartseeker),target.heartseeker+=heartseeker,target.enfeebled+=heartseeker,simController.logger.logInflicts(sourceUnit,"heartseeker",heartseeker,target),1):0},enfeeble:function(sourceUnit,skill){for(var faction=skill.y,o=getOpponent(sourceUnit),field_x_assaults=field[o].assaults,targets=[],key=0,len=field_x_assaults.length;key<len;key++){var target=field_x_assaults[key];target.isAlive()&&target.isInFaction(faction)&&targets.push(key)}return applyDebuff(sourceUnit,skill,"hexes",targets,field_x_assaults,function(target,skillValue){target.enfeebled+=skillValue})},weakenself:function(sourceUnit,skill){return activationSkills.weaken(sourceUnit,skill)},weaken:function(sourceUnit,skill){var o,faction=skill.y;switch(skill.id){case"weakenself":o=getOwner(sourceUnit);break;default:o=getOpponent(sourceUnit)}var all=skill.all,field_x_assaults=field[o].assaults,targets=[],getTargets=function(include0Strength){for(var key=0,len=field_x_assaults.length;key<len;key++){var target=field_x_assaults[key];target.isAlive()&&target.isInFaction(faction)&&(all||target.isActiveNextTurn()&&target.isUnjammed()&&(include0Strength||target.hasAttack()))&&targets.push(key)}};getTargets(!1),targets.length||getTargets(!0);return applyDebuff(sourceUnit,skill,"weakens",targets,field_x_assaults,function(target,skillValue){target.attack_weaken+=skillValue})}};function applyDebuff(sourceUnit,skill,skillVerb,targetKeys,targetField,doApplyDebuff){if(!targetKeys.length)return 0;var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,skill.x),amount=skill.x+enhanced;skill.all||(targetKeys=chooseRandomTarget(targetKeys));for(var affected=0,key=0,len=targetKeys.length;key<len;key++){var target=targetField[targetKeys[key]];target.invisible?(target.invisible--,simController.logger.logInvisibile(sourceUnit,skillVerb,target)):(affected++,doApplyDebuff(target,amount),simController.logger.logStatusEffect(sourceUnit,skillVerb,target,enhanced,amount),target.backlash&&backlash(sourceUnit,target))}return affected}var earlyActivationSkills={enlarge:function(sourceUnit,skill){var faction=skill.y,p=getOwner(sourceUnit),rally=skill.x,enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,rally);rally+=enhanced;for(var all=skill.all,field_p_assaults=field[p].assaults,targets=[],key=0,len=field_p_assaults.length;key<len;key++){(target=field_p_assaults[key]).isAlive()&&target.isInFaction(faction)&&(all||target.isUnjammed()&&target.isActive())&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var affected=0;for(key=0,len=targets.length;key<len;key++){var target=field_p_assaults[targets[key]],amount=rally;if(!amount){var mult=skill.mult;amount=Math.ceil(target.attack*mult)}target.attack_rally+=amount,simController.logger.logStatusEffect(sourceUnit,"enlarges",target,enhanced,amount),affected++}return affected},rally:function(sourceUnit,skill){for(var faction=skill.y,p=getOwner(sourceUnit),rally=skill.x,all=skill.all,field_p_assaults=field[p].assaults,targets=[],key=0,len=field_p_assaults.length;key<len;key++){(target=field_p_assaults[key]).isAlive()&&target.isInFaction(faction)&&(all||target.isActive()&&target.isUnjammed())&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,rally);rally+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var target;if((target=field_p_assaults[targets[key]]).nullified)target.nullified--,simController.logger.logNullified(sourceUnit,"empowers",target);else{affected++;var amount=rally;if(!amount){var mult=skill.mult;amount=Math.ceil(target.attack*mult)}target.attack_rally+=amount,simController.logger.logStatusEffect(sourceUnit,"empowers",target,enhanced,amount)}}return affected},legion:function(sourceUnit,skill){var p=getOwner(sourceUnit),field_p_assaults=field[p].assaults,amount=skill.x,enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,amount);amount+=enhanced;var faction=skill.y,target_key=sourceUnit.key-1,len=target_key+2;target_key<0&&(target_key+=2);for(var affected=0;target_key<=len;){var target=field_p_assaults[target_key];target&&target.isActive()&&target.isInFaction(faction)&&(target.nullified?(target.nullified--,simController.logger.logNullified(sourceUnit,"activates legion and empowers",target)):(affected++,target.attack_rally+=amount,simController.logger.logStatusEffect(sourceUnit,"activates legion and empowers",target,enhanced,amount))),target_key+=2}return affected},fervor:function(sourceUnit,skill){var p=getOwner(sourceUnit),field_p_assaults=field[p].assaults,rally=skill.x,enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,rally);rally+=enhanced;var faction=skill.y,fervorAmount=0,target_key=sourceUnit.key-1,len=target_key+2;for(target_key<0&&(target_key+=2);target_key<=len;){var target=field_p_assaults[target_key];target&&target.isInFaction(faction)&&(fervorAmount+=rally),target_key+=2}return fervorAmount?(sourceUnit.attack_rally+=fervorAmount,simController.logger.logStatusEffect(sourceUnit,"fervors",target,enhanced,fervorAmount),1):0},barrage:function(sourceUnit,skill){var o=getOpponent(sourceUnit),barrages=skill.x,faction=skill.y,all=skill.all,field_x_assaults=field[o].assaults,enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,barrages);barrages+=enhanced;for(var i=0;i<barrages;i++){for(var targets=[],key=0,len=field_x_assaults.length;key<len;key++){(targetUnit=field_x_assaults[key]).isAlive()&&targetUnit.isInFaction(faction)&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var affected=0;for(key=0,len=targets.length;key<len;key++){var targetUnit;if((targetUnit=field_x_assaults[targets[key]]).invisible)targetUnit.invisible--,simController.logger.logInvisibile(sourceUnit,"throws a bomb at",targetUnit);else{affected++;var strike_damage=1,damageInfo=modifySkillDamage(targetUnit,strike_damage,enhanced,{enfeeble:!0});strike_damage=damageInfo.damage,doDamage(sourceUnit,targetUnit,strike_damage,function(){simController.logger.logDamage(sourceUnit,targetUnit,"Barrage","throws a bomb at",damageInfo)})}}}return affected},enhance:function(sourceUnit,skill){for(var faction=skill.y,p=getOwner(sourceUnit),x=skill.x,s=(faction=skill.y,skill.s),mult=skill.mult,all=skill.all,field_p_assaults=field[p].assaults,require_active_turn=requiresActiveTurn(s),targets=[],key=0,len=field_p_assaults.length;key<len;key++){(target=field_p_assaults[key]).isAlive()&&target.isInFaction(faction)&&(all||!require_active_turn||target.isActive()&&target.isUnjammed())&&target.hasSkill(s)&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var affected=0;for(key=0,len=targets.length;key<len;key++){var target;if((target=field_p_assaults[targets[key]]).nullified)target.nullified--,simController.logger.logNullified(sourceUnit,"enhances",target);else{affected++;var enhancements=target.enhanced,amountEnhanced=x;if(0<x)enhancements[s]=(enhancements[s]||0)+x;else if(0<mult){enhancements[s]=-mult;amountEnhanced=100*mult+"%"}simController.logger.logStatusEffect(sourceUnit,"enhances "+s+" of ",target,0,amountEnhanced)}}return affected},enrage:function(sourceUnit,skill){for(var p=getOwner(sourceUnit),faction=skill.y,enrage=skill.x,all=skill.all,field_p_assaults=field[p].assaults,targets=[],key=0,len=field_p_assaults.length;key<len;key++){(target=field_p_assaults[key]).isAlive()&&target.isInFaction(faction)&&targets.push(key)}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,enrage);enrage+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var target,amount=enrage;(target=field_p_assaults[targets[key]]).nullified?(target.nullified--,simController.logger.logNullified(sourceUnit,"enrages",target)):(affected++,skill.mult&&(amount=Math.ceil(skill.mult*target.health)),target.enraged+=amount,simController.logger.logStatusEffect(sourceUnit,"enrages",target,enhanced,amount))}return affected},imbue:function(sourceUnit,skill){for(var faction=skill.y,p=getOwner(sourceUnit),x=skill.x,s=skill.s,all=skill.all,field_p_assaults=field[p].assaults,require_active_turn=requiresActiveTurn(s),targets=[],key=0,len=field_p_assaults.length;key<len;key++){(target=field_p_assaults[key]).isAlive()&&target.isInFaction(faction)&&(all||!require_active_turn||target.isActive()&&target.isUnjammed())&&targets.push(key)}if(!targets.length)return 0;skill={id:s,x:x};all||(targets=chooseRandomTarget(targets));var affected=0;for(key=0,len=targets.length;key<len;key++){var target;if((target=field_p_assaults[targets[key]]).nullified)target.nullified--,simController.logger.logNullified(sourceUnit,"enhances",target);else if(affected++,target.hasSkill(s)){var enhancements=target.enhanced;enhancements[s]=(enhancements[s]||0)+x,simController.logger.logImbuesNew(sourceUnit,target,s,x)}else target.imbue(skill),simController.logger.logImbuesExisting(sourceUnit,target,s,x)}return affected},mark:function(sourceUnit,skill){for(var faction=skill.y,o=getOpponent(sourceUnit),mark=skill.x,all=skill.all,field_x_assaults=field[o].assaults,markTarget=sourceUnit.mark_target,targets=[],key=0,len=field_x_assaults.length;key<len;key++){if((target=field_x_assaults[key]).isAlive()&&target.isInFaction(faction)){if(target.uid===markTarget){targets=[key];break}targets.push(key)}}if(!targets.length)return 0;all||(targets=chooseRandomTarget(targets));var enhanced=unitInfoHelper.getEnhancement(sourceUnit,skill.id,mark);mark+=enhanced;var affected=0;for(key=0,len=targets.length;key<len;key++){var target;affected++,(target=field_x_assaults[targets[key]]).enfeebled+=mark,sourceUnit.mark_target=target.uid,simController.logger.logStatusEffect(sourceUnit,"marks",target,enhanced,mark),skill.countdown=1}return affected}},onPlaySkills={ambush:function(sourceUnit,targetUnit,skill){var x=skill.x,base=skill.base,mult=skill.mult,damage=x;if(!damage){mult=skill.mult;damage=Math.ceil(targetUnit[base]*mult)}return doDamage(sourceUnit,targetUnit,damage,function(){simController.logger.logDamage(sourceUnit,targetUnit,"Ambush","ambushes",{originalDamage:damage,damage:damage})}),1},slow:function(sourceUnit,target,skill){var x=skill.x,base=skill.base,mult=skill.mult,slow=x;if(!slow){mult=skill.mult;slow=Math.ceil(target[base]*mult)}return target.timer+=slow,simController.logger.logStatusEffect(sourceUnit,"slows",target,0,slow),1}},onDeathSkills={unearth:function(dying,killer,skill){if(!dying.isToken){var unearthedUnit=unitInfoHelper.create(skill.card||dying.id,skill.level||skill.x),unearthedCard=cardApi.byIdWithBgeApplied(unearthedUnit,null,!0);unearthedCard.isToken=!0;var mult=skill.mult;return mult&&(unearthedCard.attack=Math.floor(dying.attack*mult),unearthedCard.health=Math.floor(dying.health*mult)),playCard(unearthedCard,dying.owner,!0),simController.logger.logAction(unearthedCard,"is unearthed"),1}},reanimate:function(dying,killer,skill){return dying.reanimated?0:(dying.health_left=skill.x,dying.reanimated=!0,simController.logger.logReanimate(dying),1)}};function doActivationSkills(sourceUnit){if(sourceUnit.silenced)simController.logger.logSilenced(sourceUnit);else for(var skills=sourceUnit.skill,isAlive=makeLivenessCheck(sourceUnit),i=0,len=skills.length;i<len&&isAlive();i++){var skill=skills[i];if(!skill.countdown){var affected=getActivatedSkill(activationSkills,skill.id)(sourceUnit,skill);skill.c&&0<affected&&(skill.countdown=skill.c),events.onActivationSkills(field,turn,sourceUnit)}}}function shuffle(list){var j,tempi,tempj,i=list.length;if(0===i)return!1;for(;--i;)j=~~(Math.random()*(i+1)),tempi=list[i],tempj=list[j],list[i]=tempj,list[j]=tempi}function onCardChosen(turn,chosenCard){events.onCardChosen(),performTurns(turn,function(chosenCard){return function(turn,field,first_player,second_player){if(turn%2)var p=first_player,o=second_player;else var p=second_player,o=first_player;var deck_p_deck=deck[p].deck;return playCard(deck_p_deck[chosenCard],p,turn),removeFromDeck(deck_p_deck,chosenCard),performTurnActions(p,o,field,turn),!0}}(chosenCard))}function performTurns(turn,resumeTurn){if(SIMULATOR.pause)return SIMULATOR.pause=!1;var done=function(turn,resumeTurn){var first_player,second_player;second_player=SIMULATOR.config.surgeMode?(first_player="cpu","player"):(first_player="player","cpu");if(0<turn){if(!resumeTurn(turn,field,first_player,second_player,!1))return!1;if(!field.player.commander.isAlive()||!field.cpu.commander.isAlive())return!(simulating=!1)}for(turn++;turn<=max_turns+1;turn++){if(turn===max_turns+1)return!(simulating=!1);if(setupTurn(turn,first_player,second_player,field),!performTurn(turn,field,first_player,second_player))return!1;if(!field.player.commander.isAlive()||!field.cpu.commander.isAlive())return simulating=!1,simController.logger.logTurnEnd(turn),!0}return!(simulating=!1)}(turn,resumeTurn);return done&&user_controlled&&simController.debugEnd(),done}function performTurn(turn,field,first_player,second_player){if(turn%2)var p=first_player,o=second_player;else p=second_player,o=first_player;return!!function(p,turn){var deck_p=deck[p],deck_p_deck=deck_p.deck,deck_p_ordered=deck_p.ordered;if(deck_p_deck[0]){SIMULATOR.waiting=!1;var card_picked=0;if(1===deck_p_deck.length)card_picked=0;else{for(var i=0;i<deck_p_deck.length;i++){var card=deck_p_deck[i];if(card.trap&&(playCard(card.trap,p,turn),card.trap=!1),2===i)break}card_picked=deck_p.chooseCard(deck_p_deck,deck_p_ordered,turn)}if(card_picked<0)return!1;playCard(deck_p_deck[card_picked],p,turn),removeFromDeck(deck_p_deck,card_picked)}return!0}(p,turn)&&(performTurnActions(p,o,field,turn),!0)}function setupTurn(turn,first_player,second_player,field){if((simulation_turns=turn)%2)var p=first_player,o=second_player;else p=second_player,o=first_player;simController.logger.logTurnStart(turn,p,field,deck);var field_p=field[p],field_o=field[o],field_p_assaults=field_p.assaults,field_o_assaults=field_o.assaults;doCountDowns(field_p.commander);for(var i=0,len=field_p_assaults.length;i<len;i++){var current_assault=field_p_assaults[i];0<current_assault.timer&&(3===turn&&SIMULATOR.config.tournamentMode||(current_assault.timer--,simController.logger.logAction(current_assault,"reduces its timer")));var valor=current_assault.valor;if(valor){var enemy=field_o_assaults[i];enemy&&current_assault.adjustedAttack()<enemy.adjustedAttack()?(current_assault.attack_valor+=valor,simController.logger.logGainAttack(current_assault,"activates valor",valor)):simController.logger.logCannotValor(current_assault,enemy)}current_assault.enfeebled=current_assault.envenomed+current_assault.heartseeker,current_assault.enraged=0,current_assault.invisible=0,current_assault.protected=0,current_assault.warded=0,current_assault.enhanced={},current_assault.removeImbue(),doCountDowns(current_assault)}}function removeFromDeck(deck,index){for(var key=index,len=deck.length-1;key<len;)deck[key]=deck[++key];deck.length=key}function chooseCardUserManually(shuffledDeck,orderedDeck,turn){for(var hand=shuffledDeck.slice(0,3),cardsInHand=[],drawableHand=[],handIdx=0,hand_len=hand.length;handIdx<hand_len;handIdx++){var card=hand[handIdx],text=handIdx+": "+card.name;1<card.maxLevel&&(text+="{"+card.level+"/"+card.maxLevel+"}"),cardsInHand.push(text),drawableHand.push(card)}return events.onPresentCardChoice(field,drawableHand,onCardChosen,turn),-1}function chooseCardOrdered(shuffledDeck,orderedDeck,turn){if(void 0===orderedDeck)return 0;for(var hand=shuffledDeck.slice(0,3),played=!1,orderIdx=0,deck_len=orderedDeck.length;orderIdx<deck_len;orderIdx++){for(var cardInHand,desiredCard=orderedDeck[orderIdx],handIdx=0,hand_len=hand.length;handIdx<hand_len;handIdx++)if(cardInHand=hand[handIdx],unitInfoHelper.areEqual(desiredCard,cardInHand)){played=!0;break}if(played){for(var len=orderedDeck.length-1;orderIdx<len;orderIdx++)orderedDeck[orderIdx]=orderedDeck[orderIdx+1];return orderedDeck.length=orderIdx,handIdx}}return-1}function chooseCardRandomly(shuffledDeck,orderedDeck,turn){var hand=shuffledDeck.slice(0,3);return~~(Math.random()*hand.length)}function chooseCardByPoints(shuffledDeck,orderedDeck,turn){for(var hand=shuffledDeck.slice(0,3),card_picked=-1,bestRank=-1,i=0;i<hand.length;i++){var rank=getCardRanking(hand[i]);bestRank<rank&&(bestRank=rank,card_picked=i)}return card_picked}function chooseFirstCard(shuffledDeck,orderedDeck,turn){return 0}function getCardRanking(card){var cardID=card.id.toString();return 6*parseInt(card.rarity)+3*(4<cardID.length?parseInt(cardID[0]):0)+(parseInt(card.level)-parseInt(card.maxLevel))}function performTurnActions(p,o,field,turn){for(var field_p=field[p],field_p_commander=field_p.commander,field_p_assaults=field_p.assaults,field_o=field[o],field_o_commander=field_o.commander,field_o_assaults=field_o.assaults,i=0;i<battlegrounds.onTurn.length;i++){var battleground=battlegrounds.onTurn[i];battleground.enemy_only&&"cpu"!==p||(battleground.ally_only&&"player"!==p||(battleground.owner=p,doEarlyActivationSkills(battleground),doActivationSkills(battleground)))}doEarlyActivationSkills(field_p.commander);for(var key=0,len=field_p_assaults.length;key<len;key++){setPassiveStatus(currentUnit=field_p_assaults[key],"evade","invisible"),setPassiveStatus(currentUnit,"absorb","warded")}!function(fieldOfActivePlayer){for(var unitsOfActivePlayer=fieldOfActivePlayer.assaults,unit_key=0,unit_len=unitsOfActivePlayer.length;unit_key<unit_len;unit_key++){var currentUnit=unitsOfActivePlayer[unit_key];if(currentUnit.isAlive()&&currentUnit.isActive()&&currentUnit.isUnjammed()){var dualstrike=currentUnit.flurry;dualstrike&&0===dualstrike.countdown&&currentUnit.hasAttack()&&(dualstrike.countdown=dualstrike.c,currentUnit.dualstrike_triggered=!0),doEarlyActivationSkills(currentUnit)}}}(field_p),doActivationSkills(field_p_commander);for(key=0,len=field_p_assaults.length;key<len;key++){var currentUnit;if((currentUnit=field_p_assaults[key]).isAlive()&&currentUnit.isActive())if(currentUnit.jammed)simController.logger.logFrozen(currentUnit);else{var activations=1;for(currentUnit.dualstrike_triggered&&(activations++,simController.logger.logDualstrike(currentUnit));0<activations;activations--)if(doActivationSkills(currentUnit),currentUnit.isAlive())if(currentUnit.hasAttack()){if(doAttack(currentUnit,field_o_assaults,field_o_commander),!field_o_commander.isAlive()||!field_p_commander.isAlive())return;if(!currentUnit.isAlive())break}else 0<currentUnit.permanentAttack()&&simController.logger.logWeakened(currentUnit)}}!function(field_p_assaults){for(var key=0,len=field_p_assaults.length;key<len;key++){var current_assault=field_p_assaults[key];if(current_assault.jammedSelf?current_assault.jammedSelf=!1:current_assault.jammed=!1,current_assault.attack_rally=0,current_assault.attack_weaken=0,current_assault.nullified=0,current_assault.dualstrike_triggered=!1,current_assault.silenced=!1,current_assault.regenerate&&current_assault.isDamaged()){var regen_health=current_assault.regenerate,enhanced=unitInfoHelper.getEnhancement(current_assault,"regenerate",regen_health);regen_health+=enhanced;var healthMissing=current_assault.health-current_assault.health_left;healthMissing<=regen_health&&(regen_health=healthMissing),current_assault.health_left+=regen_health,simController.logger.logGainHealth(current_assault,"regenerates",regen_health)}var amount=current_assault.poisoned;if(amount){var warded=current_assault.warded,damageInfo={originalDamage:amount};warded&&(amount-=applyDamageReduction(current_assault,"warded",amount),damageInfo.damage=amount,damageInfo.modifiers={Ward:warded}),doDamage(null,current_assault,amount,function(){simController.logger.logDamage(null,current_assault,"Poison","poison damage",damageInfo)})}var amount=current_assault.envenomed;if(amount){var warded=current_assault.warded,damageInfo={originalDamage:amount};warded&&(amount-=applyDamageReduction(current_assault,"warded",amount),damageInfo.damage=amount,damageInfo.modifiers={Ward:warded}),doDamage(null,current_assault,amount,function(){simController.logger.logDamage(null,current_assault,"Venom","venom damage",damageInfo)})}var scorch=current_assault.scorched;if(scorch){var damageInfo={originalDamage:amount=scorch.amount};warded&&(amount-=applyDamageReduction(current_assault,"warded",amount),damageInfo.damage=amount,damageInfo.modifiers={Ward:warded}),doDamage(null,current_assault,amount,function(){simController.logger.logDamage(null,current_assault,"Scorch","scorch damage",damageInfo,function(){if(current_assault.isAlive()&&!current_assault.scorched)return" and scorch wears off"})}),1<scorch.timer?scorch.timer--:current_assault.scorched=0}var corroded=current_assault.corroded;if(corroded)if(corroded.timer--,corroded.timer<0)current_assault.corroded=!1,current_assault.attack_corroded=0,simController.logger.logAction(current_assault,"recovers from corrosion");else{var corrosion=corroded.amount;current_assault.attack_corroded=corrosion,simController.logger.logAction(current_assault,"loses "+corrosion+" attack to corrosion")}current_assault.isAlive()||doOnDeathSkills(current_assault,null)}}(field_p_assaults),removeDeadUnits("player"),removeDeadUnits("cpu"),simController.logger.logTurnEnd(turn)}function setPassiveStatus(assault,skillName,statusName){var statusValue=0;assault[skillName]&&(statusValue=assault[skillName],statusValue+=unitInfoHelper.getEnhancement(assault,skillName,statusValue));assault[statusName]=statusValue}function modifySkillDamage(target,originalDamage,enhanced,exclusions){var enfeeble=(exclusions=exclusions||{}).enfeeble?0:target.enfeebled||0,shrouded=exclusions.stasis?0:checkShroud(target),protect=exclusions.protect?0:target.protected||0,warded=exclusions.ward?0:target.warded||0,damage=originalDamage+enfeeble-shrouded;return warded&&(damage-=applyDamageReduction(target,"warded",damage)),protect&&(damage-=applyDamageReduction(target,"protected",damage)),shrouded&&(damage-=shrouded),damage<0&&(damage=0),{originalDamage:originalDamage,damage:damage,modifiers:{Enhance:enhanced,Enfeeble:enfeeble,Stasis:-shrouded,Barrier:-protect,Ward:-warded}}}function applyDamageReduction(target,statusName,damage){var statusValue=target[statusName];return statusValue<=damage?(target[statusName]=0,statusValue):(target[statusName]-=damage,damage)}function doCountDowns(unit){doSkillCountDowns(unit,unit.skill),doSkillCountDowns(unit,unit.earlyActivationSkills);var dualStrike=unit.flurry;dualStrike&&dualStrike.countdown&&(dualStrike.countdown--,simController.logger.logChargeSkill(unit,dualStrike))}function doSkillCountDowns(unit,skills){for(var i=0,len=skills.length;i<len;i++){var skill=skills[i];skill.countdown&&(skill.countdown--,simController.logger.logChargeSkill(unit,skill))}}function doAttack(current_assault,field_o_assaults,field_o_commander){var target=field_o_assaults[current_assault.key];if(target&&target.isAlive()){var adjacent,taunted=!1;if(!target.taunt)if((adjacent=field_o_assaults[current_assault.key-1])&&adjacent.taunt)target=adjacent,taunted=!0;else(adjacent=field_o_assaults[current_assault.key+1])&&adjacent.taunt&&(target=adjacent,taunted=!0);taunted&&simController.logger.logAction(target,"taunts",current_assault)}else target=field_o_commander;var damage=current_assault.adjustedAttack(),enfeeble=target.enfeebled,pierce=current_assault.pierce,damageInfo={originalDamage:current_assault.attack,modifiers:{Berserk:current_assault.attack_berserk,Valor:current_assault.attack_valor,Rally:current_assault.attack_rally,Weaken:-current_assault.attack_weaken,Corrosion:-current_assault.attack_corroded,Enfeeble:enfeeble}},damageModifiers=damageInfo.modifiers;if(damage+=enfeeble,pierce){var enhanced=unitInfoHelper.getEnhancement(current_assault,"pierce",pierce);pierce+=enhanced}else pierce=0;var protect=target.protected,armor=target.armored,shrouded=checkShroud(target),remainingPierce=pierce;if(protect&&(damageModifiers.Barrier=-protect,remainingPierce&&(damageModifiers.Pierce=pierce,protect<=remainingPierce?(remainingPierce-=protect,protect=0,target.protected=0):(protect-=remainingPierce,target.protected-=pierce,remainingPierce=0)),protect&&(protect<=damage?(damage-=protect,target.protected=0):(target.protected-=damage,damage=0))),[{logName:"Shroud",status:"stasis",value:shrouded},{logName:"Armor",status:"armored",value:armor}].forEach(function(modifierInfo){var value=modifierInfo.value;value&&(value+=unitInfoHelper.getEnhancement(target,modifierInfo.status,value),damageModifiers[modifierInfo.logName]=-value,remainingPierce&&(damageModifiers.Pierce=pierce,value<remainingPierce?value=0:value-=remainingPierce),damage-=value)}),damage<0&&(damage=0),doDamage(current_assault,target,damage,function(){simController.logger.logDamage(current_assault,target,"Attack","attacks",damageInfo)}),events.onUnitAttacked(field,turn,current_assault),field_o_commander.isAlive()){if(0<damage&&target.isAssault()&&target.isAlive()){if(current_assault.poison){var poison=current_assault.poison;(poison+=enhanced=unitInfoHelper.getEnhancement(current_assault,"poison",poison))>target.poisoned&&(target.poisoned=poison,simController.logger.logInflicts(current_assault,"poison",poison,target))}if(current_assault.venom){var venom=current_assault.venom;if((venom+=enhanced=unitInfoHelper.getEnhancement(current_assault,"venom",venom))>target.envenomed){var hexIncrease=venom-target.envenomed;target.envenomed=venom,target.enfeebled+=hexIncrease,simController.logger.logInflicts(current_assault,"venom",venom,target)}}if(current_assault.nullify){var nullify=current_assault.nullify;nullify+=enhanced=unitInfoHelper.getEnhancement(current_assault,"nullify",nullify),target.nullified+=nullify,simController.logger.logInflicts(current_assault,"nullify",nullify,target)}if(current_assault.silence&&(target.silenced=!0,simController.logger.logInflicts(current_assault,"silence",null,target)),current_assault.daze){var dazed=current_assault.daze;dazed+=enhanced=unitInfoHelper.getEnhancement(current_assault,"daze",dazed),target.attack_weaken+=dazed,simController.logger.logInflicts(current_assault,"dazed",dazed,target)}}if(0<damage&&current_assault.isAlive()){if(current_assault.leech&&current_assault.isDamaged()){var leech_health=current_assault.leech;leech_health+=enhanced=unitInfoHelper.getEnhancement(current_assault,"leech",leech_health);var healthMissing=current_assault.health-current_assault.health_left;healthMissing<=leech_health&&(leech_health=healthMissing),current_assault.health_left+=leech_health,simController.logger.logSiphon(current_assault,"siphons",leech_health)}if(current_assault.reinforce){var reinforce=current_assault.reinforce;reinforce+=enhanced=unitInfoHelper.getEnhancement(current_assault,"reinforce",reinforce),current_assault.protected+=reinforce,simController.logger.logStatusEffect(current_assault,"reinforces",current_assault,enhanced,reinforce)}if(target.counter){var counterBase=0+target.counter,counterEnhancement=unitInfoHelper.getEnhancement(target,"counter",counterBase);doCounterDamage(current_assault,target,"Vengance",counterBase,counterEnhancement)}if(target.counterburn){var scorch=target.counterburn||0;scorch+=enhanced=unitInfoHelper.getEnhancement(target,"counterburn",scorch),current_assault.scorched?(current_assault.scorched.amount+=scorch,current_assault.scorched.timer=2):current_assault.scorched={amount:scorch,timer:2},simController.logger.logInflicts(target,"counterburn",scorch,current_assault)}if(target.counterpoison){poison=target.counterpoison||0;(poison+=enhanced=unitInfoHelper.getEnhancement(target,"counterpoison",poison))>current_assault.poisoned&&(current_assault.poisoned=poison,simController.logger.logInflicts(target,"counterpoison",poison,current_assault))}if(target.fury){var furyBase=target.fury,furyEnhancement=unitInfoHelper.getEnhancement(target,"counter",furyBase);if(target.isAlive()){var fury=furyBase+furyEnhancement;target.attack_berserk+=fury,simController.logger.logGainAttack(target,"activates fury",fury)}doCounterDamage(current_assault,target,"Fury",furyBase,furyEnhancement)}if(0<target.enraged&&(target.attack_berserk+=target.enraged,simController.logger.logGainAttack(target,"is enraged",target.enraged)),current_assault.berserk){var berserk=current_assault.berserk;berserk+=enhanced=unitInfoHelper.getEnhancement(current_assault,"berserk",berserk),current_assault.attack_berserk+=berserk,simController.logger.logGainAttack(target,"activates berserk",berserk)}}if(target.corrosive){var corrosion=target.corrosive||0;corrosion+=enhanced=unitInfoHelper.getEnhancement(target,"corrosive",corrosion),current_assault.corroded?(current_assault.corroded.amount+=corrosion,current_assault.corroded.timer=2):current_assault.corroded={amount:corrosion,timer:2},simController.logger.logInflicts(target,"corrosion",corrosion,current_assault),current_assault.attack_corroded=corrosion,simController.logger.logAction(current_assault,"loses "+corrosion+" attack to corrosion")}current_assault.isAlive()||doOnDeathSkills(current_assault,target),events.onUnitDone(field,turn,current_assault)}}function doCounterDamage(attacker,defender,counterType,counterBase,counterEnhancement){var damageInfo=modifySkillDamage(attacker,counterBase+counterEnhancement,counterEnhancement,{enfeeble:!0});doDamage(defender,attacker,damageInfo.damage,function(){simController.logger.logDamage(null,attacker,counterType,counterType.toLowerCase()+" damage",damageInfo)})}SIMULATOR.pause=!1;var battlegrounds,noop=function(){},events={onCardPlayed:noop,onEarlyActivationSkills:noop,onActivationSkills:noop,onOnDeathSkills:noop,onPresentCardChoice:noop,onCardChosen:noop,onUnitAttacked:noop,onUnitDone:noop},deck={},field={},simulation_turns=0,simulating=!1,user_controlled=!1,turn=0,totalDeckHealth=0,totalCpuDeckHealth=0;return SIMULATOR.simulate=function(config){if(simulating=!0,function(config){SIMULATOR.config=config,SIMULATOR.simulation_turns=0;var deck={cpu:{deck:[]},player:{deck:[]}};SIMULATOR.deck=deck,SIMULATOR.field={cpu:{assaults:[]},player:{assaults:[]}},playerCardsCached&&(deck.player=loadDeck.copyDeck(playerCardsCached)),config.selectedMission&&1<config.missionLevel&&config.missionLevel<7?(cpuDeckCached=loadDeck.mission(config.selectedMission,config.missionLevel),cpuCardsCached=loadDeck.getDeckCards(cpuDeckCached,"cpu")):config.selectedRaid&&(cpuDeckCached=loadDeck.raid(config.selectedRaid,config.raidLevel),cpuCardsCached=loadDeck.getDeckCards(cpuDeckCached,"cpu")),cpuCardsCached&&(deck.cpu=loadDeck.copyDeck(cpuCardsCached)),config.playerOrdered&&!config.playerExactOrder&&(deck.player.ordered=loadDeck.copyCardList(deck.player.deck)),config.cpuOrdered&&!config.cpuExactOrder&&(deck.cpu.ordered=loadDeck.copyCardList(deck.cpu.deck)),deck.player.chooseCard=config.userControlled?chooseCardUserManually:config.playerOrdered?chooseCardOrdered:chooseCardRandomly,deck.cpu.chooseCard=config.cpuOrdered?chooseCardOrdered:config.pvpAI?chooseCardByPoints:config.cpuExactOrder?chooseCardRandomly:chooseFirstCard}(config),config.playerExactOrder?config.playerOrdered||(deck.player.shuffleHand=!0):shuffle(deck.player.deck),config.cpuExactOrder?config.cpuOrdered||(deck.cpu.shuffleHand=!0):shuffle(deck.cpu.deck),function(field){var uids=field.uids={};["player","cpu"].forEach(function(player){for(var pDeck=deck[player],cards=pDeck.deck,uidBase="player"===player?1:101,i=0;i<cards.length;i++){var uid=uidBase+i,card=cards[i];card.owner=player,card.played=!1,card.uid=uid,uids[uid]=card}var commander=pDeck.commander;commander.owner=player,commander.health_left=commander.health,commander.reusableSkills||commander.resetTimers();var uid="player"===player?-1:-2;commander.uid=uid,uids[uid]=commander,field[player].commander=commander})}(field),config.siegeMode){var tower=BATTLEGROUNDS[config.towerType].effect[config.towerLevel];if(tower){tower=unitInfoHelper.create(tower.id,tower.level);var towerCard=cardApi.byIdWithBgeApplied(tower);towerCard.uid=150,playCard(field.uids[150]=towerCard,"cpu",-1,!0)}}return performTurns(0)},SIMULATOR.setupDecks=function(config){playerDeckCached=config.playerHash?base64.decodeHash(config.playerHash):loadDeck.defaultDeck(),playerCardsCached=loadDeck.getDeckCards(playerDeckCached,"player"),config.pvpAI=!0,config.cpuHash?(cpuDeckCached=base64.decodeHash(config.cpuHash),config.selectedMission&&(config.pvpAI=!1)):config.selectedMission?(cpuDeckCached=loadDeck.mission(config.selectedMission,config.missionLevel),config.pvpAI=!1):config.selectedRaid?(cpuDeckCached=loadDeck.raid(config.selectedRaid,config.raidLevel),config.pvpAI=!1):cpuDeckCached=loadDeck.defaultDeck(),cpuCardsCached=loadDeck.getDeckCards(cpuDeckCached,"cpu")},SIMULATOR.onPlaySkills=onPlaySkills,SIMULATOR.calculatePoints=function(forceWin){var uids=field.uids,healthStats={player:{total:0,taken:0},cpu:{total:0,taken:0}};for(var i in uids){var unit=uids[i],stats=healthStats[unit.owner];stats&&(stats.total+=unit.health,(unit.played||unit.isCommander())&&(stats.taken+=unit.health-unit.health_left))}healthStats.player.percent=stats.taken/stats.total,healthStats.cpu.percent=stats.taken/stats.total;var matchPoints,commander_o=field.cpu.commander;return matchPoints=SIMULATOR.config.cpuHash?commander_o.isAlive()&&!forceWin?Math.floor(25*healthStats.cpu.percent):130-Math.floor(15*healthStats.player.percent):commander_o.isAlive()&&!forceWin?(matchPoints=Math.floor(healthStats.cpu.percent/.02),Math.max(5,matchPoints)):200-Math.floor(healthStats.player.percent/.02)},Object.defineProperties(SIMULATOR,{deck:{get:function(){return deck},set:function(value){deck=value}},field:{get:function(){return field},set:function(value){field=value}},battlegrounds:{get:function(){return battlegrounds},set:function(value){battlegrounds=value}},simulation_turns:{get:function(){return simulation_turns},set:function(value){simulation_turns=value}},simulating:{get:function(){return simulating},set:function(value){simulating=value}},totalDeckHealth:{get:function(){return totalDeckHealth},set:function(value){totalDeckHealth=value}},totalCpuDeckHealth:{get:function(){return totalCpuDeckHealth},set:function(value){totalCpuDeckHealth=value}},user_controlled:{get:function(){return user_controlled},set:function(value){user_controlled=value}},events:{get:function(){return events},set:function(value){events=value}}}),SIMULATOR}),define("singleThreaded",["bgeApi","matchTimer","urlHelper","debugLog","simController","simulatorBase","ui","matchStats"],function(bgeApi,matchTimer,urlHelper,debugLog,simController,simulator,ui,matchStats){"use strict";function runSims(config){if(simulator.user_controlled)runSim(config,!0)&&simController.debugEnd();else if(!debugLog.enabled&&!debugLog.cardsPlayedOnly||debugLog.massDebug||debugLog.firstLoss||debugLog.firstWin)if(0<simulator.remainingSims){if(run_sims_batch<=run_sims_count){var simpersecbatch=0;if(0<run_sims_batch){run_sims_count=0;var elapse=matchTimer.elapsed(),batch_elapse=matchTimer.batchElapsed();simpersecbatch=0===batch_elapse?0:run_sims_batch/batch_elapse,ui.setSimStatus("Running simulations...",elapse,simpersecbatch.toFixed(1)),ui.showWinrate()}(run_sims_batch=1)<simpersecbatch&&(run_sims_batch=Math.ceil(simpersecbatch/8)),run_sims_batch>simulator.remainingSims&&(run_sims_batch=simulator.remainingSims),(debugLog.enabled||debugLog.cardsPlayedOnly)&&(debugLog.massDebug||debugLog.firstLoss||debugLog.firstWin)&&(run_sims_batch=1),matchTimer.startBatch(),simController.statusTimeout=setTimeout(runSims,1,config);for(var i=0;i<run_sims_batch;i++)runSim(config)}}else{run_sims_batch=run_sims_count=0,matchTimer.stop();elapse=matchTimer.elapsed();var simpersec=matchStats.matchesPlayed/elapse;simpersec=simpersec.toFixed(2),ui.displayText(debugLog.getLog()),ui.setSimStatus("Simulations complete.",elapse,simpersec),ui.showWinrate(),ui.show(),simController.endSimsCallback&&simController.endSimsCallback()}else runSim(config,!0),simController.debugEnd()}simController.startsim=function(){matchStats.totalTurns=0,matchTimer.reset(),debugLog.clear(),matchStats.matchesPlayed=0,run_sims_batch=0;var config=ui.getConfiguration();return simController.setDebugLogger(),simulator.battlegrounds=bgeApi.getBattlegrounds(config.getbattleground,config.selfbges,config.enemybges,config.mapbges,config.selectedCampaign,config.missionLevel,config.selectedRaid,config.raidLevel),ui.hide(),simulator.remainingSims=config.simsToRun,simulator.setupDecks(config),matchStats.matchesWon=0,matchStats.matchesLost=0,matchStats.matchesDrawn=0,matchStats.totalPoints=0,ui.displayText(""),config.userControlled?ui.setSimStatus(""):(ui.hideTable(),ui.setSimStatus("Initializing simulations...")),window.ga("send","event","simulation","start","single-threaded",config.simsToRun),simController.statusTimeout=setTimeout(runSims,0,config),!1},simController.stopsim=function(){matchTimer.stop();var elapse=matchTimer.elapsed(),simpersec=matchStats.matchesPlayed/elapse;simpersec=simpersec.toFixed(2),simulator.simulating=!1,simulator.user_controlled||(ui.setSimStatus("Simulations interrupted.",elapse,simpersec),ui.showWinrate()),ui.show(),simController.stop_sims_callback&&simController.stop_sims_callback()},simController.clearStatusTimeout=function(){simController.statusTimeout&&clearTimeout(simController.statusTimeout),simController.statusTimeout=null};var seedtest=urlHelper.paramValue("seedtest")||0;function runSim(config,skipResults){if(seedtest&&Math.seedrandom(seedtest++),!simulator.simulate(config))return!1;skipResults||simController.processSimResult()}simController.processSimResult=function(){var result;return result=!!simulator.field.player.commander.isAlive()&&(!simulator.field.cpu.commander.isAlive()||"draw"),0<run_sims_batch&&(0<simulator.remainingSims&&simulator.remainingSims--,run_sims_count++),"draw"===result?matchStats.matchesDrawn++:result?matchStats.matchesWon++:matchStats.matchesLost++,matchStats.totalPoints+=simulator.calculatePoints(),matchStats.matchesPlayed++,matchStats.totalTurns+=simulator.simulation_turns,(debugLog.enabled||debugLog.cardsPlayedOnly)&&(debugLog.firstLoss?"draw"!==result&&result||(simulator.remainingSims=0):debugLog.firstWin&&result&&"draw"!==result&&(simulator.remainingSims=0),simController.logger.logOutcome(result,matchStats.matchesPlayed,SIMULATOR.remainingSims),simController.logger.logStartBattle(simulator.remainingSims)),result};var run_sims_count=0,run_sims_batch=0}),function(){"use strict";var simController=require("simController"),matchStats=require("matchStats"),base64=require("base64"),ui=require("ui"),matchTimer=require("matchTimer"),urlHelper=require("urlHelper");function getBgesFromHash(paramName){var hashedBges=urlHelper.paramValue(paramName),bges=[];if(hashedBges)for(var i=0;i<hashedBges.length;i+=2)bges.push(base64.toDecimal(hashedBges.substring(i,i+2)));return bges.join(",")}ui.getConfiguration=function(){return{playerHash:urlHelper.paramValue("deck1"),playerOrdered:urlHelper.paramDefined("ordered"),playerExactOrder:urlHelper.paramDefined("exactorder"),cpuHash:urlHelper.paramValue("deck2"),cpuOrdered:urlHelper.paramDefined("ordered2"),cpuExactOrder:urlHelper.paramDefined("exactorder2"),userControlled:!1,selectedBges:getBgesFromHash("bges"),selfbges:getBgesFromHash("selfbges"),enemybges:getBgesFromHash("enemybges"),mapbges:getBgesFromHash("mapBges"),selectedCampaign:urlHelper.paramValue("campaign"),selectedMission:urlHelper.paramValue("mission"),missionLevel:urlHelper.paramValue("mission_level")||"7",selectedRaid:urlHelper.paramValue("raid"),raidLevel:urlHelper.paramValue("raid_level")||"25",simsToRun:urlHelper.paramValue("sims")||"10000",surgeMode:urlHelper.paramDefined("surge"),tournamentMode:urlHelper.paramDefined("tournament"),siegeMode:urlHelper.paramDefined("siege"),towerLevel:Math.min(Math.max(urlHelper.paramValue("tower_level")||18,0),18),towerType:urlHelper.paramValue("tower_type")||501}},simController.startsim(),simController.endSimsCallback=function(){var elapse=matchTimer.elapsed(),simpersec=(matchStats.matchesPlayed/elapse).toFixed(2);console.log("Sims per second:",simpersec);var winrate=(matchStats.matchesWon/matchStats.matchesPlayed*100).toFixed(2);console.log("Winrate:",winrate)}}();
//# sourceMappingURL=engineTest.min.js.map